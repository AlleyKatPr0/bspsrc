package info.ata4.bspsrc.app.src.gui.components.main;

import info.ata4.bspsrc.app.src.ObservableBspSourceConfig;
import info.ata4.bspsrc.app.util.swing.GuiUtil;
import info.ata4.bspsrc.decompiler.BspSourceConfig;
import info.ata4.bspsrc.decompiler.util.SourceFormat;
import info.ata4.bspsrc.lib.app.SourceAppDB;
import info.ata4.bspsrc.lib.app.SourceAppId;
import net.miginfocom.swing.MigLayout;

import javax.swing.*;
import java.awt.*;
import java.util.Comparator;
import java.util.Map;
import java.util.stream.IntStream;

import static java.util.Objects.requireNonNull;

public class OtherPanel extends JPanel {

	private final ObservableBspSourceConfig config;

	private final JCheckBox chkDebug = new JCheckBox("Debug mode") {{
		setToolTipText("""
				<html>
				The debug mode produces <i>very</i> verbose output<br>
				text and writes additional data into the VMF file.
				</html>""");
		addActionListener(e -> OtherPanel.this.config.updateConfig(c -> c.debug = isSelected()));
	}};
	private final JCheckBox chkLoadLumpFiles = new JCheckBox("Load lump files") {{
		setToolTipText("""
				<html>
				When enabled, external lump files  <i>(.lmp)</i> with the same<br>
				name as the BSP file will be processed during decompilation.
				</html>""");
		addActionListener(e -> OtherPanel.this.config.updateConfig(c -> c.loadLumpFiles = isSelected()));
	}};
	private final JCheckBox chkHammerVisgroups = new JCheckBox("Create hammer visgroups") {{
		setToolTipText("""
				<html>
				Automatically group instanced entities to visgroups.
				<p><b>Note:</b> World brushes created from instances can't<br>
				be grouped because of missing information.</p>
				</html>""");
		addActionListener(e -> OtherPanel.this.config.updateConfig(c -> c.writeVisgroups = isSelected()));
	}};
	private final JCheckBox chkHammerCameras = new JCheckBox("Create hammer cameras") {{
		setToolTipText("""
				Create Hammer viewport cameras above
				each player spawn to ease navigation.""");
		addActionListener(e -> OtherPanel.this.config.updateConfig(c -> c.writeCameras = isSelected()));
	}};
	private final JCheckBox chkExtractEmbedded = new JCheckBox("Extract embedded files") {{
		setToolTipText("Extract all resource files that are embedded into the BSP file.");
		addActionListener(e -> OtherPanel.this.config.updateConfig(c -> c.unpackEmbedded = isSelected()));
	}};
	private final JCheckBox chkSmartExtract = new JCheckBox("Smart extracting") {{
		setToolTipText("Don't extract files that were automatically generated by vBsp.");
		addActionListener(e -> OtherPanel.this.config.updateConfig(c -> c.smartUnpack = isSelected()));
	}};
	private final JComboBox<MapFormatEntry> cmbBspFormat = new JComboBox<>() {{
		setToolTipText("""
				<html>
				<p>Overrides the internal game detection for maps.</p>
				<p>Select <i>"Automatic"</i> for automatic detection.</p>
				<br>
				<b>Warning:</b> Change only if the game isn't detected<br>
				correctly, wrong values can cause program errors!
				</html>""");
		addActionListener(e -> OtherPanel.this.config.updateConfig(c -> c.defaultAppId = ((MapFormatEntry) cmbBspFormat.getSelectedItem()).appId()));
	}};
	private final JComboBox<SourceFormat> cmbVmfFormat = new JComboBox<>(SourceFormat.values()) {{
		setToolTipText("Extract all resource files that are embedded into the BSP file.");
		addActionListener(e -> OtherPanel.this.config.updateConfig(c -> c.sourceFormat = (SourceFormat) cmbVmfFormat.getSelectedItem()));
	}};

	public OtherPanel(ObservableBspSourceConfig config) {
		this.config = requireNonNull(config);

		initCmbBspFormat();

		config.addListener(this::update);
		update();

		setLayout(new MigLayout(
				"",
				"",
				"[]u[]"
		));

		add(createUpperPanel(), "wrap");
		add(createLowerPanel());
	}

	private void initCmbBspFormat() {
		Map<Integer, String> apps = SourceAppDB.getInstance().getAppList();
		apps.entrySet().stream()
				.map(entry -> new MapFormatEntry(entry.getKey(), entry.getValue()))
				.sorted(Comparator.comparing(MapFormatEntry::toString))
				.forEach(cmbBspFormat::addItem);

		cmbBspFormat.insertItemAt(new MapFormatEntry(SourceAppId.UNKNOWN, "Automatic"), 0);
		cmbBspFormat.insertItemAt(new MapFormatEntry(SourceAppId.DEFAULT, "Generic"), 1);
		cmbBspFormat.setSelectedIndex(0);
		cmbBspFormat.setRenderer(new DefaultListCellRenderer() {
			@Override
			public Component getListCellRendererComponent(
					JList<?> list,
					Object value,
					int index,
					boolean isSelected,
					boolean cellHasFocus
			)
			{
				if (value instanceof MapFormatEntry entry)
					value = entry.name();
				
				var component = super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
				if ("Automatic".equals(value) || "Generic".equals(value))
					component.setFont(component.getFont().deriveFont(Font.BOLD));
				else
					component.setFont(component.getFont().deriveFont(Font.PLAIN));
				
				return component;
			}
		});
	}

	private JPanel createUpperPanel() {
		var panel = new JPanel(new MigLayout("insets 0"));
		panel.add(chkDebug);
		panel.add(chkHammerVisgroups, "wrap");
		panel.add(chkLoadLumpFiles);
		panel.add(chkHammerCameras, "wrap");
		panel.add(chkExtractEmbedded, "span, wrap");
		panel.add(chkSmartExtract, "gapleft i, span, wrap");
		return panel;
	}

	private JPanel createLowerPanel() {
		var panel = new JPanel(new MigLayout("insets 0"));
		panel.add(new JLabel("BSP format"));
		panel.add(cmbBspFormat, "wrap");
		panel.add(new JLabel("VMF format"));
		panel.add(cmbVmfFormat, "wrap");
		return panel;
	}

	private void update() {
		chkSmartExtract.setEnabled(config.get(c -> c.unpackEmbedded));

		chkDebug.setSelected(config.get(c -> c.debug));
		chkLoadLumpFiles.setSelected(config.get(c -> c.loadLumpFiles));
		chkHammerVisgroups.setSelected(config.get(c -> c.writeVisgroups));
		chkHammerCameras.setSelected(config.get(c -> c.writeCameras));
		chkExtractEmbedded.setSelected(config.get(c -> c.unpackEmbedded));
		chkSmartExtract.setSelected(config.get(c -> c.smartUnpack));

		// TODO: I don't really like how this works, but it is good enough for now...
		int defaultAppId = config.get(c -> c.defaultAppId);
		int bspFormatIndex = IntStream.range(0, cmbBspFormat.getItemCount())
				.filter(i -> cmbBspFormat.getItemAt(i).appId() == defaultAppId)
				.findAny()
				.orElse(-1);

		cmbBspFormat.setSelectedIndex(bspFormatIndex);
		cmbVmfFormat.setSelectedItem(config.get(c -> c.sourceFormat));
	}

	private record MapFormatEntry(
			int appId,
			String name
	) {}

	public static void main(String[] args) {
		GuiUtil.debugDisplay(() -> new OtherPanel(new ObservableBspSourceConfig(new BspSourceConfig())));
	}
}
